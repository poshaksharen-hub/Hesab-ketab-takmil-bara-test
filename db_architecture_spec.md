
# سند معماری و تحلیل کامل سیستم حسابداری خانواده

این سند به تحلیل و طراحی کامل مدل داده و منطق‌های اصلی اپلیکیشن می‌پردازد.

---

## ۱) تحلیل کامل وضعیت موجودیت‌ها

در این بخش، وضعیت هر یک از موجودیت‌های اصلی برنامه بررسی شده و موارد ناقص یا حذف‌شده تکمیل می‌شوند.

| موجودیت (Entity) | وضعیت در `backend.json` فعلی | نیازمندی‌ها |
| :--- | :--- | :--- |
| **Cheques (چک‌ها)** | **وجود ندارد** | نیاز به طراحی کامل مدل، وضعیت‌ها و روابط |
| **Due Reminders (یادآوری‌ها)** | **وجود ندارد** | نیاز به طراحی کامل |
| **Analytics / Dashboard** | **وجود ندارد** | نیاز به تعریف مفاهیم و منطق محاسباتی |
| **Reports (گزارش‌ها)** | **وجود ندارد** | نیاز به تعریف مفاهیم و منطق محاسباتی |
| **Payees (طرف‌حساب‌ها)** | **ناقص** | نیاز به تکمیل فیلدها و رفتار |
| **Categories (دسته‌بندی‌ها)** | **ناقص** | نیاز به تکمیل فیلدها و رفتار |
| **Bank Accounts** | **کامل** | مدل فعلی نیازهای اصلی را پوشش می‌دهد. |
| **Loans** | **کامل** | مدل فعلی کامل و صحیح است. |
| **Previous Debts** | **کامل** | مدل فعلی کامل و صحیح است. |
| **Financial Goals** | **کامل** | مدل فعلی کامل و صحیح است. |
| **Transfers** | **کامل** | مدل فعلی کامل و صحیح است. |
| **Chat Messages** | **کامل** | مدل فعلی کامل و صحیح است. |
| **Incomes** | **کامل** | مدل فعلی کامل و صحیح است. |
| **Expenses** | **کامل** | مدل فعلی کامل و صحیح است. |

---

## ۲) طراحی موجودیت‌های جدید و تکمیل موارد ناقص

### ۲.۱) منطق کامل «چک‌ها» (Cheques)

چک به عنوان یک **تعهد پرداخت (Liability)** در آینده عمل می‌کند و تا زمان پاس شدن، نباید به عنوان هزینه قطعی ثبت شود.

**رفتارها:**
- **چک صادرشده (Outgoing):** تمرکز اصلی اپلیکیشن روی این نوع چک است. کاربر یک چک برای پرداخت در آینده صادر می‌کند.
- **چک دریافت‌شده (Incoming):** این مورد پیچیدگی را بالا می‌برد و می‌تواند به عنوان یک نوع «درآمد آتی» مدیریت شود، اما در فاز اول، بهتر است روی چک‌های صادرشده تمرکز کنیم.
- **انتقال چک (Endorsement):** در این نسخه از اپلیکیشن پشتیبانی نمی‌شود.
- **برگشت خوردن چک (Bounce):** یک وضعیت کلیدی است که باید مدیریت شود. چک برگشتی همچنان یک بدهی باقی می‌ماند.
- **پاس شدن از حساب دیگر:** پشتیبانی نمی‌شود. هر چک به یک حساب بانکی مشخص متصل است.

**تأثیر بر موجودی حساب:**
1.  **هنگام صدور چک:** مبلغ چک باید از **موجودی قابل برداشت** کسر شده و به بخش **موجودی مسدود شده (Blocked Balance)** در `bankAccounts` اضافه شود. موجودی کل حساب تغییر نمی‌کند.
2.  **هنگام پاس شدن (Clearing):** مبلغ چک از موجودی کل و موجودی مسدودشده کسر می‌شود و یک رکورد `Expense` جدید ایجاد می‌شود.
3.  **هنگام ابطال یا برگشت:** مبلغ چک از موجودی مسدودشده آزاد شده و به موجودی قابل برداشت بازمی‌گردد.

**جدول `cheques`:**

| نام فیلد | نوع داده | توضیحات |
| :--- | :--- | :--- |
| `id` | `uuid` | Primary Key |
| `chequeNumber` | `string` | شماره چک (صیادی یا سریال) |
| `amount` | `number` | مبلغ چک |
| `issueDate` | `timestamp` | تاریخ صدور |
| `dueDate` | `timestamp` | **تاریخ سررسید** |
| `status` | `string` | `pending`, `cleared`, `bounced`, `cancelled` |
| `bankAccountId` | `uuid` | FK به `bank_accounts.id` (حسابی که چک از آن صادر شده) |
| `payeeId` | `uuid` | FK به `payees.id` (دریافت‌کننده چک) |
| `description` | `text` | توضیحات مربوط به چک |
| `transactionId` | `uuid` | برای اتصال به `Expense` در زمان پاس شدن |
| `relatedExpenseId` | `uuid` | FK به `expenses.id` (پس از پاس شدن) |
| `chequeImagePath` | `string` | مسیر فایل تصویر چک در Storage |
| `signaturePath` | `string` | مسیر فایل امضا در Storage |
| `statusHistory` | `jsonb` | آرایه‌ای از تاریخچه تغییر وضعیت‌ها |
| `createdAt`, `updatedAt` | `timestamp` | |
| `isDeleted`, `deletedAt` | `boolean`, `timestamp` | برای Soft Delete |

---

### ۲.۲) تکمیل مدل «طرف‌حساب‌ها» (Payees)

طرف‌حساب برای گزارش‌گیری دقیق از هزینه‌ها و درآمدها ضروری است.

**جدول `payees`:**

| نام فیلد | نوع داده | توضیحات |
| :--- | :--- | :--- |
| `id` | `uuid` | Primary Key |
| `name` | `string` | نام شخص، فروشگاه یا سازمان |
| `type` | `string` | `person`, `store`, `organization` |
| `phone` | `string` | شماره تلفن (اختیاری) |
| `notes` | `text` | یادداشت‌های مربوط به این طرف‌حساب |
| `tags` | `text[]` | آرایه‌ای از تگ‌ها برای دسته‌بندی (مثلا: `خانواده`, `همکار`) |
| `isArchived` | `boolean` | برای بایگانی کردن (به جای حذف) |
| `createdAt`, `updatedAt` | `timestamp` | |

**روابط و رفتارها:**
- یک `payee` می‌تواند در `expenses`, `incomes`, `cheques`, `loans` استفاده شود.
- در گزارش‌ها، می‌توان هزینه‌های مربوط به یک `payee` خاص را agregat کرد.

---

### ۲.۳) تکمیل مدل «دسته‌بندی‌ها» (Categories)

دسته‌بندی‌ها برای بودجه‌بندی و تحلیل رفتار مالی ضروری هستند.

**جدول `categories`:**

| نام فیلد | نوع داده | توضیحات |
| :--- | :--- | :--- |
| `id` | `uuid` | Primary Key |
| `name` | `string` | نام دسته‌بندی (مثلا: `خوراک`, `ایاب‌وذهاب`) |
| `type` | `string` | `expense` یا `income` |
| `color` | `string` | کد رنگ برای نمایش در UI |
| `icon` | `string` | نام آیکون برای نمایش در UI |
| `parentId` | `uuid` | FK به `categories.id` (برای ساخت ساختار درختی) |
| `budgetLimit` | `number` | سقف بودجه ماهانه برای این دسته‌بندی (اختیاری) |
| `sortOrder` | `integer` | برای مرتب‌سازی نمایش دسته‌بندی‌ها |
| `isArchived` | `boolean` | برای بایگانی کردن |
| `createdAt`, `updatedAt` | `timestamp` | |

**روابط و رفتارها:**
- هر `expense` و `income` یک `categoryId` دارد.
- داشبورد و گزارش‌ها بر اساس دسته‌بندی‌ها، تحلیل‌های مهمی ارائه می‌دهند (مثلا: «نمودار دایره‌ای هزینه‌ها»).

---

### ۲.۴) طراحی مدل «یادآوری‌های سررسید» (Due Reminders)

این موجودیت برای اطلاع‌رسانی تاریخ‌های مهم (سررسید چک، قسط وام) به کار می‌رود.

**جدول `reminders`:**

| نام فیلد | نوع داده | توضیحات |
| :--- | :--- | :--- |
| `id` | `uuid` | Primary Key |
| `title` | `string` | عنوان یادآوری (مثلا: «سررسید چک شماره ۱۲۳») |
| `dueDate` | `timestamp` | تاریخ سررسید |
| `relatedEntityType` | `string` | `cheque`, `loan_payment`, `debt_payment` |
| `relatedEntityId` | `uuid` | FK به جدول مربوطه |
| `notificationScheduledAt` | `timestamp` | زمانی که نوتیفیکیشن باید ارسال شود |
| `isDismissed` | `boolean` | آیا کاربر یادآوری را بسته است؟ |
| `userId` | `uuid` | کاربری که باید نوتیفیکیشن را دریافت کند |
| `createdAt`, `updatedAt` | `timestamp` | |

**رفتار:**
- یک فرآیند خودکار (Cron Job) می‌تواند روزانه اجرا شده و با بررسی جداول `cheques`, `loans`, `previousDebts`، رکوردهای `reminders` را برای رویدادهای نزدیک ایجاد کند.

---

## ۳) مفاهیم جدید: آمار، داشبورد و گزارش‌ها

این بخش‌ها جداول مجزا در دیتابیس نیستند، بلکه **نتیجه agregat و تحلیل داده‌های موجود** هستند. منطق آن‌ها باید در سطح API و کوئری‌های SQL پیاده‌سازی شود.

### ۳.۱) آمار و داشبورد (Analytics & Dashboard)
داشبورد باید خلاصه‌ای از وضعیت مالی فعلی را نمایش دهد.
- **محاسبات لازم:**
  - **موجودی کل:** `SUM(balance)` از تمام `bankAccounts`.
  - **درآمد ماه جاری:** `SUM(amount)` از `incomes` در ماه فعلی.
  - **هزینه ماه جاری:** `SUM(amount)` از `expenses` در ماه فعلی.
  - **جریان نقدینگی (Cash Flow):** درآمد - هزینه.
  - **بدهی‌های پیش‌رو:** `SUM(amount)` از چک‌های `pending` و اقساط پرداخت‌نشده وام‌ها.
  - **نمودار دایره‌ای هزینه‌ها:** `GROUP BY` بر اساس `categoryId`.

### ۳.۲) گزارش‌ها (Reports)
گزارش‌ها به کاربر امکان تحلیل عمیق‌تر داده‌ها را در بازه‌های زمانی مختلف می‌دهند.
- **انواع گزارش:**
  - **گزارش هزینه/درآمد:** فیلتر بر اساس بازه زمانی، دسته‌بندی، طرف‌حساب و حساب بانکی.
  - **گزارش جریان نقدینگی:** مقایسه درآمد و هزینه در ماه‌های مختلف.
  - **گزارش بدهی‌ها:** نمایش وضعیت تمام وام‌ها، بدهی‌ها و چک‌ها.
  - **گزارش بر اساس تگ:** نمایش تمام تراکنش‌های مرتبط با یک تگ خاص.

---

## ۴) موارد اضافی و Cross-Cutting Concerns

- **امضا (Signature) و عکس چک (Cheque Image):**
  - **منطق:** این موارد باید به عنوان فایل در **Supabase Storage** ذخیره شوند.
  - **پیاده‌سازی:** فیلدهای `signaturePath` و `chequeImagePath` در جدول `cheques` مسیر فایل را نگهداری می‌کنند.

- **فایل ضمیمه (Attachments):**
  - برای مدیریت عمومی ضمائم (مانند فاکتور برای یک هزینه)، می‌توان یک جدول عمومی `attachments` طراحی کرد:
    - `id`, `relatedEntityType`, `relatedEntityId`, `filePath`, `fileType`, `uploadedByUserId`, `createdAt`

- **یادداشت‌ها (Notes) و تگ‌ها (Tags):**
  - این موارد به صورت فیلدهای `text` و `text[]` (آرایه‌ای از متون) در جداول مربوطه (مانند `expenses`, `payees`) اضافه شده‌اند که برای شروع کافی و کارآمد است.
